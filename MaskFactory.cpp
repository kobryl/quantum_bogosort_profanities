#include "MaskFactory.h"

/*
*	Implementation of MaskFactory class.
*	
*	Provides an effictient method for preliminary checking whether a word could be a profanity or not, by matching the letters the words consist of.
*	When an instance of the class is initialized, it checks whether the cache file that stores the words' masks is recent. 
*	If the file is not recent, the class creates a new cache file by reading the word list and computing the masks for the words.
* 
*	A mask is a numerical representation of the letters a word consists of. 
*	It's created by setting specific bits in an int to '1', based on indices computed from the given word (e.g. 'a' = LSB, 'z' = 25th bit from LSB).
*/

/**
*	@brief Default constructor: initializes masks vector.
*	Creates a new cache file to read if the old one is not recent.
*/
MaskFactory::MaskFactory() {
	// Profanity masks initialization (cache creation if needed)
	if (!isCacheFileRecent(PROFANITY_LIST_CACHE_NAME, PROFANITY_LIST_NAME))
		// 3 parameters: allowed characters between letters of a word, allowed characters before word and after a word
		createCacheFile(PROFANITY_LIST_CACHE_NAME, PROFANITY_LIST_NAME, 3);	
	readMaskCacheFile(PROFANITY_LIST_CACHE_NAME, &profanityMasks);

	// Whitelist masks initialization (cache creation if needed)
	if (!isCacheFileRecent(WHITELIST_CACHE_NAME, WHITELIST_NAME))
		// 2 parameters: allowed characters before a word and after a word
		createCacheFile(WHITELIST_CACHE_NAME, WHITELIST_NAME, 2);
	readMaskCacheFile(WHITELIST_CACHE_NAME, &whitelistMasks);

	currentWordMask = 0;
}


/**
*	@brief Compares two masks and returns true if either mask is a subset of the other.
*	Masks are considered matching when two words (from which the masks were constructed) consist of the same letters.
* 
*	@param firstMask: The first mask to compare.
*	@param secondMask: The second mask to compare.
*	@returns true if either mask is a subset of the other, false otherwise.
*/
bool MaskFactory::doMasksMatch(int firstMask, int secondMask) {
	int comparisonMask = (firstMask & secondMask);
	if (comparisonMask == firstMask || comparisonMask == secondMask) return true;
	return false;
}


/**
*	@brief Converts a string to a mask, ignoring any characters that are not lowercase letters. 
*	The mask is generated by setting bits corresponding to the letters in the word.
* 
*	@param word: The string to convert to a mask.
*	@param skip (optional): The number of elements in the word to skip before generating the mask. Defaults to 0.
*	@returns An integer representing the generated mask.
*/
int MaskFactory::parseStringToMask(std::string& word, int skip = 0) {
	int mask = 0;
	int letterNumber;
	for (int i = skip; i < word.length(); i++) {
		if (word[i] < 'a' || word[i] > 'z')
			continue;
		letterNumber = word[i] - 'a';
		mask |= 1 << letterNumber;
	}

	return mask;
}


/**
*	@brief: Converts a processed word to a mask, ignoring any characters that are not lowercase letters. 
*	The mask is generated by setting bits corresponding to the letters in the word.
*
*	@param word: A reference to a vector of pairs of pairs of integers and characters, representing the processed word.
*	@param skip (optional): The number of elements in the word to skip before generating the mask. Defaults to 0.
*	@returns An integer representing the generated mask.
*/
int MaskFactory::parseProcessedWordToMask(std::vector<std::pair<std::pair<int, int>, char>>& word, int skip = 0) {
	int mask = 0;
	int letterNumber;
	for (int i = skip; i < word.size(); i++) {
		if (word[i].second < 'a' || word[i].second > 'z')		// if not a lowercase letter, skip it
			continue;
		letterNumber = word[i].second - 'a';
		mask |= 1 << letterNumber;
	}

	return mask;
}


/**
*	@brief Reads a mask cache file and stores the masks in a vector.
*	The mask cache file is expected to have the following format:
*		the first line is a timestamp;
*		each subsequent line contains a single integer representing a mask.
*
*	@param cacheName: The name of the mask cache file to read.
*	@param masks: A pointer to a vector of integers, where the read masks will be stored.
*/
void MaskFactory::readMaskCacheFile(const char* cacheName, std::vector<int>* masks) {
	std::ifstream list(cacheName);
	std::string str;
	int number = 0;

	std::getline(list, str);	// skip the first line, which is a timestamp
	while (list >> number) {
		(*masks).push_back(number);
	}

	list.close();
}


/**
*	@brief Creates a cache file from a given list file.
*	For each word, it parses the word into a mask and writes the mask to the cache file. 
*	After writing each mask to the file, the function skips over the specified number of irrelevant parameters.
* 
*	@param cacheName: The name of the cache file to create.
*	@param listName: The name of the list file to use as a source for the cache file.
*	@param irrelevantParamsAfterWord: The number of irrelevant parameters to skip after reading a word from the list file.
*/
void MaskFactory::createCacheFile(const char* cacheName, const char* listName, int irrelevantParamsAfterWord) {
	std::ofstream cache(cacheName);
	std::ifstream list(listName);
	std::string textFromFile;

	cache << getListModificationTime(listName);
	
	int temp;
	while (list >> textFromFile) {
		cache << "\n";
		cache << parseStringToMask(textFromFile);
		for (int i = 0; i < irrelevantParamsAfterWord; i++)
			list >> temp;		// skip an irrelevant parameter, such as allowed characters between word letters.
	}

	cache.close();
	list.close();
}


/**
*	@brief Returns the modification time for a list specified by fileName.
*
*	@param fileName: The name of the file for which to get the modification time.
*	@returns The modification time of the file.
*/
time_t MaskFactory::getListModificationTime(const char* fileName) {
	time_t time;
	struct stat attrib;
	__int64 ltime;
	_time64(&ltime);

	stat(fileName, &attrib);
	time = attrib.st_mtime;

	return time;
}


/**
*	@brief Determines whether a cache file is recent or not.
*
*	@param cacheName: The name of the cache file to check.
*	@param listName: The name of the file for which the cache file is being checked.
*	@returns true if the cache file is recent (i.e., its recorded time matches the modification time of the file), false otherwise.
*/
bool MaskFactory::isCacheFileRecent(const char* cacheName, const char* listName) {
	std::ifstream cache(cacheName);
	std::string textFromFile;
	time_t recordedTime;

	cache >> recordedTime;
	cache.close();

	if (recordedTime != getListModificationTime(listName)) return false;
	return true;
}


/**
*	@brief Sets the currentWordMask field to the mask generated from a given processed word.
* 
*	@param word: A reference to a vector representing the processed word.
*	@param skip (optional): The number of elements in the word to skip before generating the mask. Defaults to 0.
*/
void MaskFactory::setCurrentWordMask(std::vector<std::pair<std::pair<int, int>, char>>& word, int skip = 0) {
	currentWordMask = parseProcessedWordToMask(word, skip);
}


/**
*	@brief Checks whether the currently set word's mask in currentWordMask could be a profanity.
* 
*	@param profanityIndex: The index of the profanity mask to compare with the currentWordMask.
*	@returns A boolean indicating whether the currentWordMask could be a profanity based on the specified mask.
*/
bool MaskFactory::canBeProfanity(int profanityIndex) {
	return doMasksMatch(currentWordMask, profanityMasks[profanityIndex]);
}


/**
*	@brief Checks whether the currently set word's mask in currentWordMask could be whitelisted.
*
*	@param profanityIndex: The index of the whitelist mask to compare with the currentWordMask.
*	@returns A boolean indicating whether the currentWordMask could be whitelisted based on the specified mask.
*/
bool MaskFactory::canBeWhitelisted(int whitelistIndex) {
	return doMasksMatch(currentWordMask, whitelistMasks[whitelistIndex]);
}


// Debug functions

/**
*	@brief Prints the profanity and whitelist masks.
*	The masks are printed in binary format, as a string of characters, and as decimal numbers.
*/
void MaskFactory::printMasks() {
	std::cout << "Profanity masks:\n";
	int i = 0;
	for (int mask : profanityMasks) {
		std::bitset<32> bitMask = std::bitset<32>(mask);
		std::cout << i++ << ": " << bitMask << " = ";
		for (int i = 0; i < 32; i++) {
			if (bitMask.test(i)) std::cout << (char)('a' + i);
		}
		std::cout << " = " << mask << "\n";
	}

	std::cout << "\nWhitelist masks:\n";
	i = 0;
	for (int mask : whitelistMasks) {
		std::bitset<32> bitMask = std::bitset<32>(mask);
		std::cout << i++ << ": " << bitMask << " = ";
		for (int i = 0; i < 32; i++) {
			if (bitMask.test(i)) std::cout << (char)('a' + i);
		}
		std::cout << " = " << mask << "\n";
	}
}